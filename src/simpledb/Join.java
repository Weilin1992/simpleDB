package simpledb;
import java.util.*;
import java.io.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

    private JoinPredicate _predicate;
    private DbIterator _outerRelation;
    private DbIterator _innerRelation;
    private Iterator<Tuple> _outerPage=null;
    private Iterator<Tuple> _innerPage=null;
    private HeapFileIterator _innerHeapFile;
    private HeapFileIterator _outerHeapFile;
    private boolean isFirsttime = true;

    private Tuple _outerRecent=null;
    private Tuple _innerRecent=null;

    private int _joinType = 0;
    private int _numMatches =0;
    private int _numComp=0;

    private int _testPage = 0;

    private int count = 0;

    //private ArrayList<Tuple> tuples = new ArrayList<Tuple>();

  
    public static final int SNL = 0;
    public static final int PNL = 1;    
    public static final int BNL = 2;    
    public static final int SMJ = 3;    
    public static final int HJ = 4;    
    /**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
	_predicate = p;
    _outerRelation = child1;
    _innerRelation = child2;
   
    }

    public void setJoinAlgorithm(int joinAlgo){
	_joinType = joinAlgo;
    }
    /**
     * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible implementation logic.
     */
    public TupleDesc getTupleDesc() {
        TupleDesc ret = TupleDesc.combine(_outerRecent.getTupleDesc(),_innerRecent.getTupleDesc());
	   return ret;

    }

    public void open()
        throws DbException, NoSuchElementException, TransactionAbortedException, IOException {
            _outerRelation.open();
            _innerRelation.open();
            /*
            SeqScan _outer = (SeqScan)_outerRelation;
            SeqScan _inner = (SeqScan)_innerRelation;

            _outer.open();
            _inner.open();

            _outerHeapFile = (HeapFileIterator)_outer.getIterator();
            _innerHeapFile = (HeapFileIterator)_inner.getIterator();

            _outerHeapFile.open();
            _innerHeapFile.open();
            //System.out.println("not failed yet");
            _outerPage = _outerHeapFile.getCurrentPage().iterator();
            _innerPage = _innerHeapFile.getCurrentPage().iterator();
            */
		//IMPLEMENT THIS

    }

    public void close() {
        _outerRelation.close();
        _innerRelation.close();
        super.close();
//IMPLEMENT THIS

    }

    public void rewind() throws DbException, TransactionAbortedException, IOException {
        _outerRelation.rewind();
        _innerRelation.rewind();
//IMPLEMENT THIS
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException{
	switch(_joinType){
	case SNL: return SNL_readNext();
	case PNL: return PNL_readNext();
	case BNL: return BNL_readNext();
	case SMJ: return SMJ_readNext();
	case HJ: return HJ_readNext();
	default: return SNL_readNext();
	}
    }

    protected Tuple SNL_readNext() throws TransactionAbortedException, DbException{
    Tuple result = null;
    while(true)
    {
        _numComp++;
        //System.out.println(_numComp);
        boolean innerhasNext = false;
        boolean outerhasNext = false;
        try{
                outerhasNext = _outerRelation.hasNext();
            }catch(IOException e){
            }
        try{
                innerhasNext = _innerRelation.hasNext();
            }catch(IOException e){
            }
        while(_outerRecent!=null&&innerhasNext)
        {
            _innerRecent = _innerRelation.next();
            try{
                innerhasNext = _innerRelation.hasNext();
            }catch(IOException e){
            }
            if(_predicate.filter(_outerRecent,_innerRecent))
            {
            result = Tuple.merge(_outerRecent,_innerRecent);
            _numMatches++;
            return result;
            }
        }
        try{
                outerhasNext = _outerRelation.hasNext();
            }catch(IOException e){
            }
        if(!outerhasNext)
        {
            return null;
        }
        _outerRecent = _outerRelation.next();
        if(_innerRecent!=null)
        {
        try{
            _innerRelation.rewind();
        }catch(IOException e){

        }
    }
    }
    //return result;
    }


    protected Tuple PNL_readNext() throws TransactionAbortedException, DbException {
        Tuple result = null;
        try{
            if(isFirsttime)
            {
                _outerHeapFile = (HeapFileIterator)((SeqScan)_outerRelation).getIterator();
                _outerPage = _outerHeapFile.getCurrentPage().iterator();
                isFirsttime = false;
            }
            while(result == null)
            {
                while(_innerRecent != null || _innerRelation.hasNext()){
                if(_innerRecent == null){
                    _innerRecent = _innerRelation.next();
                }
                while(_outerPage.hasNext()){
                    _outerRecent = _outerPage.next();
                    _numComp++;
                    if(_predicate.filter(_outerRecent,_innerRecent)){
                        
                        result = Tuple.merge(_outerRecent,_innerRecent);
                        _numMatches+=1;
                        return result;
                    }   
                }
                _innerRecent = null;
                _outerPage = _outerHeapFile.getCurrentPage().iterator();
                }  
                //System.out.println(_numMatches);
                if(_outerHeapFile.hasNextPage())
                {
                    _outerPage = _outerHeapFile.nextPage().iterator();
                    _testPage++;
                    //System.out.println(_testPage);
                }
                else return null;
                _innerRelation.rewind();
            }
        }catch(IOException e){

        }
        
        
        return result;

    }


    protected Tuple BNL_readNext() throws TransactionAbortedException, DbException {
	//no need to implement this
	return null;
    }


    protected Tuple SMJ_readNext() throws TransactionAbortedException, DbException {
        Tuple result = null;
        try {
         if(_outerRecent == null&&_outerRelation.hasNext())
                _outerRecent = _outerRelation.next();
            if(_innerRecent == null&&_outerRelation.hasNext())
                _innerRecent = _innerRelation.next();
        while (true)
        {
             //System.out.println("count > 0");
            if(count > 0)
            {
                //System.out.println("count > 0");
                if(_innerRelation.hasNext())
                    _innerRecent = _innerRelation.next();
                else {
                    if(_outerRelation.hasNext())
                    {
                        _outerRecent = _outerRelation.next();
                        count--;
                        while(count > 0)
                        {
                            count--;
                            ((SeqScan)_innerRelation).previous();
                        }
                    }
                    else return null;
                }
            }
            if(_innerRecent == null)
                return null;
            if(_predicate.filterLessThan(_outerRecent,_innerRecent))
            {
                //System.out.println("filterLessThan");

                if(count > 0)
                {
                    if(_outerRelation.hasNext())
                        _outerRecent = _outerRelation.next();
                    else 
                        { 
                            count = 0;
                            return null;}
                    count++;
                    while(count > 0)
                    {
                        count--;
                        ((SeqScan)_innerRelation).previous();
                    }
                    _innerRecent = _innerRelation.next();
                } else if(_outerRelation.hasNext())
                {
                    _outerRecent = _outerRelation.next();
                    count = 0;
                }
                else return null;

            }
            else if(_predicate.filterGreaterThan(_outerRecent,_innerRecent))
            {
                //System.out.println("filtergreaterThan");
                if(_innerRelation.hasNext())
                {
                    _innerRecent = _innerRelation.next();
                    count = 0;
                }
                else return null;
            }
            else if(_predicate.filter(_outerRecent,_innerRecent))
            {
                //System.out.println("equality");
                _numMatches++;
                result = Tuple.merge(_outerRecent,_innerRecent);
                count++;
                return result;
            }
        }
   }catch(IOException e){

   }
	return result;
    }

    protected Tuple HJ_readNext() throws TransactionAbortedException, DbException {
	//no need to implement this
	return null;
    }


    private Tuple joinTuple(Tuple outer, Tuple inner, TupleDesc tupledesc){
	//IMPLEMENT THIS
	return null;
    }

    public int getNumMatches(){
	return _numMatches;
    }
    public int getNumComp(){
	return _numComp;
    }
}
